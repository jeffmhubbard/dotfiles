" vim/vimrc

" btw
runtime! archlinux.vim

" Enable Pathogen
execute pathogen#infect()

" Colorscheme and Terminal
colorscheme antsy
set term=screen-256color

" Enable filetype
if has("autocmd")
  filetype on
  filetype plugin on
  filetype indent on
endif

" Enable syntax highlighting
if has("syntax")
  syntax on
endif

"
" Common Settings
"

" Basic editor
set nowrap
set number
set cursorline
set showmatch
set scrolloff=3

" File encoding
set encoding=utf-8
set fileencoding=utf-8

" Indention
set expandtab
set smarttab
set tabstop=4
set softtabstop=4
set shiftwidth=4
set list lcs=tab:\┆\ 

" Hidden buffers
set hidden

" Autosave
set autowriteall

" Update buffer when file changes
set autoread

" Enable mouse support
set mouse=a

" Toggle paste\nopaste
set pastetoggle=<leader>z

" Backspace nice
set backspace=indent,eol,start

" Save undo history
if !isdirectory($HOME."/.vim/undo")
    call mkdir($HOME."/.vim/undo", "", 0700)
endif
set undodir=~/.vim/undo
set undofile

" Search options
set hlsearch
set incsearch
set ignorecase
set smartcase

" Vertical separator
set fillchars+=vert:│

" Menus
set wildmenu
set wildmode=list:longest,full

" Folds
set foldmethod=indent
set foldnestmax=10
set nofoldenable
set foldlevel=2

" status line
set statusline=""
set laststatus=2
set shortmess=a
set noshowmode
set noshowcmd

" Clear autocmd
augroup Local
    autocmd!
augroup END

" CWD follows current buffer
autocmd Local BufEnter * silent! lcd %:p:h

"
" Mappings that don't use plugins
"

" Edit and reload vimrc
nnoremap <silent> <leader>ve :e $MYVIMRC<CR>
nnoremap <silent> <leader>vr :so $MYVIMRC<CR>

" Save
nnoremap <leader>s :w<cr>
inoremap <leader>s <C-c>:w<cr>

" Next and previous buffers
noremap <C-N> :bnext<CR>
noremap <C-P> :bprev<CR>

" Navigate panes
noremap <C-l> <C-w>l
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k

" macros - qq record, q stop and Q apply
nnoremap Q @q
vnoremap Q :norm @q<cr>

"""
""" Plugins
"""

" lightline.vim
let g:lightline = {
    \ 'colorscheme': 'antsy',
    \ 'active': {
    \   'left': [ [ 'mode', 'paste' ],
    \             [ 'readonly', 'filename', 'modified' ] ],
    \   'right': [ [ 'lineinfo' ],
    \              [ 'percent' ],
    \              [ 'fileformat', 'fileencoding', 'filetype' ],
    \              [ 'gitbranch' ],
    \              [ 'linter_checking', 'linter_errors', 'linter_warnings', 'linter_ok' ] ],
    \
    \ },
    \ 'component_function': {
    \   'gitbranch': 'fugitive#head'
    \ },
    \ }

let g:lightline.component_expand = {
    \  'linter_checking': 'lightline#ale#checking',
    \  'linter_warnings': 'lightline#ale#warnings',
    \  'linter_errors': 'lightline#ale#errors',
    \  'linter_ok': 'lightline#ale#ok',
    \ }

let g:lightline.component_type = {
    \     'linter_checking': 'normal',
    \     'linter_warnings': 'warning',
    \     'linter_errors': 'error',
    \     'linter_ok': 'left',
    \ }

let g:lightline#ale#indicator_checking = " "
let g:lightline#ale#indicator_warnings = " "
let g:lightline#ale#indicator_errors = " "
let g:lightline#ale#indicator_ok = ""

" nerdtree
" auto open nerdtree when vim starts with directory
autocmd Local StdinReadPre * let s:std_in=1
autocmd Local VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif
" close vim if nerdtree is only window remaining
autocmd Local bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

let NERDTreeShowHidden = 1
let NERDTreeStatusline = 1
let NERDTreeWinSize = 25
let NERDTreeMinimalUI=1

let g:NERDTreeIndicatorMapCustom = {
    \ "Modified"  : "●",
    \ "Staged"    : "▲",
    \ "Untracked" : "✱",
    \ "Renamed"   : "➤",
    \ "Unmerged"  : "♦",
    \ "Deleted"   : "✖",
    \ "Dirty"     : "",
    \ "Clean"     : "",
    \ "Ignored"   : '',
    \ "Unknown"   : "?"
    \ }

map <leader>\d :NERDTreeToggle<CR>

" nerdtree-git
let g:NERDTreeShowGitStatus = 1

" vim-devicons
let g:webdevicons_conceal_nerdtree_brackets = 1

" buftabline
let g:buftabline_show = 1
let g:buftabline_numbers = 1
let g:buftabline_indicators = "on"
let g:buftabline_separators = "off"

" Tagbar
let g:tagbar_compact = 0

nmap <leader>\t :TagbarToggle<CR>

" ALE
let b:ale_linters = ['pyflakes', 'flake8', 'shellcheck']
let g:ale_fixers = {
    \ '*': ['remove_trailing_lines', 'trim_whitespace'],
    \ 'javascript': ['eslint'],
    \ 'python': ['black', 'yapf', 'autopep8', 'isort', 'add_blank_lines_for_python_control_statements'],
    \ }

let g:ale_fix_on_save = 0

nmap <leader>at <Plug>(ale_toggle)
nmap <leader>af <Plug>(ale_fix)
nmap <leader>] <Plug>(ale_next)
nmap <leader>[ <Plug>(ale_previous)

" AsyncRun auto open
let g:asyncrun_open = 10

" incsearch
let g:incsearch#auto_nohlsearch = 1

map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)
map g* <Plug>(incsearch-nohl-g*)
map g# <Plug>(incsearch-nohl-g#)

" indentLine
let g:indentLine_enabled = 1
let g:indentLine_setColors = 1
let g:indentLine_char = '┆'

" vim-fugitive
nmap <leader>gc :Gcommit<CR>
nmap <leader>gca :Gcommit --amend<CR>
nmap <leader>gw :Gwrite<CR>
nmap <leader>gp :Gpush<CR>
nmap <leader>gd :Gdiff<CR>
nmap <leader>gvd :Gvdiff<CR>
nmap <leader>gdp :diffput<CR>
nmap <leader>gdg :diffget<CR>
vmap <leader>gdp :diffput<CR>
vmap <leader>gdg :diffget<CR>

silent! helptags ALL

" vim: set ft=vim:
